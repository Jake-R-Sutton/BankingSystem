# BankingSystem

This is a small pedagogical project used to demonstrate several object-oriented design concepts.  In perusing this example, don't get too caught up in the fact that the example involves banking, in particular support for making a withdrawal from an ATM.  In no way is this example meant to show how banking software is, or should be, designed.  So many issues are glossed over, such as persistence, security, etc.  This is an example about Dependency Inversion, Design Patterns, Software Architecture, Design by Contract, and the like.

This repository contains three branches, each representing an example design.  What follows is a discussion of each alternative design and the concepts and tradeoffs it embodies:

- [Master](https://github.com/wggster/BankingSystem): This is the "base" version of the program.  It's main positive feature is its simple and direct design.  Its failing is that ATMs "know about" Banks, and Banks "know about" BankingSystems.  The result is that this system could not be incrementally developed.  an ATM could not be tested until there were Banks and BankingSystems.  Beyond this, the ATM and Bank classes are not fully minding their business (not [SRP](https://en.wikipedia.org/wiki/Single-responsibility_principle)).  They know what result codes mean and act upon them.  This results in complex methods that are hard to write contracts for (cf. [Design by Contract](https://ieeexplore.ieee.org/document/161279)).  The key example here is that when a Bank here's back from the Grantor that the withdrawal request was approved, it calles method transfer to note that it gave out money to an account holder of another bank.  BankingSystem should be making that transfer.

- [Strategy](https://github.com/wggster/BankingSystem/tree/strategy): This is a fairly simple refactoring that employs [Dependency Inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle) (and I would say the [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern) in particular) to break the above dependencies.  A Grantor interface was introduced so that ATM depends on a small abstract Grantor, not a big concrete Bank.  Grantor likewise allows Bank to depend on an abstract Grantor, not a concrete Banking System.  If we think in terms of a uses hierarchy, this is a significant improvement, in that we now have classes depending on abstractions.  This would allow testing ATMs and Banks using a mock Grantor (although see [Mocking is a Code Smell](https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a), which artfully makes the point that, in our case, ATM and Bank are not true units (in the unit testing sense) because of this dependency, abstract or not.  Parnas made similar arguments back in the 1970s in his papers on [Minimal Subsets](https://ieeexplore.ieee.org/document/1702387) and [Extension and Contraction](https://ieeexplore.ieee.org/document/1702607).  The use of the Strategy Pattern also does not address the shortcoming that ATM and Bank are not minding their own business.

- [MVP](https://github.com/wggster/BankingSystem/tree/mvp), actually hierarchical [Model-View-Presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter):  This is a much more complex refactoring, and only one of many possibilities in this particular genre.  There are perhaps better MVP solutions, but this does does demonstrate MVP.  This redesign acknowledges that an ATM has both input and output aspects, and they can be thought of as distinct responsibilities.  Whether these map to model and view, or, view and model, can be debated, because the example is too simple to make the distinction meaningful.  But it can be said that when certain inputs happen (a proper account, PIN, and dollar amount are provided), then money will be dispensed.  It would seem counterintuitive to handle this with events/implicit-invocation ala the [Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern), because an ATM should not have more than one Grantor.  True, so for this design, I considered that all sorts of Observers might be possible: auditors,<sup>[1](#footnote1)</sup> advertisers, etc.  However, we have to introduce an [architectural](http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/intro_softarch.html) [design rule](https://www.amazon.com/Design-Rules-Vol-Power-Modularity/dp/0262024667) (constraint, invariant) that requires that there be no more than one Observer of an ATM that is a Grantor.<sup>[2](#footnote2)</sup>  True to MVP, what happens is that when an event is signalled, the Presenter (aka [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern)) makes calls on the Model(s) and View to keep them in sync.  So, for example, when an ATM announces that there has been a withdrawal request, its owning Bank determines if its the owner of the account, and if it is it calls the ATM back with a dispense command.  However, because this example is demonstrating _hierarchical_ MVP, the Bank may find that it does not hold the Account, and then reannounces the withdrawal request, which the BankingSystem receives, looks for a Bank that holds the Account, and if so, calls the Bank back with a dispense (transfer) call.  A key difference between Observer and MVP is that in MVP the Presenter needs to know which objects (i.e., Models or parts of the Model) in particular need to be updated upon receiving an event.  Thus, when an ATM announces the withdrawal request, it includes itself in the request, so that the Presenter can update it appropriately.  Likewise, when the Bank re-announces, it includes itself in the announcement.  There are is a "trick" here, which is why I think this example could have a better solution.  In this latter case when a Bank announces that it has a withdrawal request, if the BankingSystem finds a Bank that holds the account, the originating ATM needs to be told it can dispense the funds, and there will be a transfer from one Account holder's Bank to the ATM-owner's Bank.  However, the BankingSystem only has a reference to the Bank.  The reason for this is to enforce a uses-hierarchy that is compliant with the [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter), perhaps more helpfully named The Principle of Least Knowledge: an object should only talk to its friends, not its friends' friends.  In our case, that means BankingSystems can know about Banks, but shouldn't know about ATMs.  To comply with the PoLK, then, I decided to use a pseudo-[Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern), which decorated the announcing Bank with the announcing ATM, so that when the BankingSystem called to update the Bank with the successful withdrawal, the ATM was on hand and could be called by the Bank to dispense the funds.  There are many other solutions that I considered.  One was for the announcing Bank to include not just itself, but a <Bank,ATM> Pair in the announcement.  Structurally, it is little different than the Decorator solution, except that the Presenter (BankingSystem) can "see" the ATM.  This is not a violation of the PoLK as long as the Presenter does not invoke a method on ATM.  Thus, the compliant solution would have the BankingSystem pass the ATM back to the Bank (e.g., bankATMPair.key.transfer(bankATMPair.value).  Another solution would be for the announcing Bank to simply "remember" which ATM is "currently active", e.g., by adding a private field to the Bank like activeATM.  Then when the Bank is called back, it can access this field.  This is subject to errors, say if concurrency is later introduced, or if there is a recursive call sequence (although this latter case could be handled by having a Stack of activeATMs that the Bank pushes/pops).




<a name="footnote1"><sup>1</sup></a>An auditor or similar behavior would probably be better provided through the Decorator Pattern so that it could stop improper transactions, not just observe and log them (although this creates the possibility of violating [LSP](https://en.wikipedia.org/wiki/Liskov_substitution_principle)).  This somewhat argues against the use of Observer or MVP for the ATM-Bank relationship, although the architectural design rule can still get the job done.

<a name="footnote2"><sup>2</sup></a>This design rule could be enforced by implementing an Observer that accepts only one registrant, but this is overconstraining, e.g., does not allow advertisers.



